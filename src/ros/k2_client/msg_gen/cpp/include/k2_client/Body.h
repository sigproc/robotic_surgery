/* Auto-generated by genmsg_cpp for file /home/prdemo/ros/local/k2_client/msg/Body.msg */
#ifndef K2_CLIENT_MESSAGE_BODY_H
#define K2_CLIENT_MESSAGE_BODY_H
#include <string>
#include <vector>
#include <map>
#include <ostream>
#include "ros/serialization.h"
#include "ros/builtin_message_traits.h"
#include "ros/message_operations.h"
#include "ros/time.h"

#include "ros/macros.h"

#include "ros/assert.h"

#include "std_msgs/Header.h"
#include "k2_client/Lean.h"
#include "k2_client/Appearance.h"
#include "k2_client/Activities.h"
#include "k2_client/Expressions.h"
#include "k2_client/JointOrientationAndType.h"
#include "k2_client/JointPositionAndState.h"

namespace k2_client
{
template <class ContainerAllocator>
struct Body_ {
  typedef Body_<ContainerAllocator> Type;

  Body_()
  : header()
  , leanTrackingState(0)
  , lean()
  , isRestricted(false)
  , isTracked(false)
  , trackingId(0)
  , clippedEdges(0)
  , engaged(false)
  , handRightConfidence(0.0)
  , handRightState(0)
  , handLeftConfidence(0.0)
  , handLeftState(0)
  , appearance()
  , activities()
  , expressions()
  , jointOrientations()
  , jointPositions()
  {
  }

  Body_(const ContainerAllocator& _alloc)
  : header(_alloc)
  , leanTrackingState(0)
  , lean(_alloc)
  , isRestricted(false)
  , isTracked(false)
  , trackingId(0)
  , clippedEdges(0)
  , engaged(false)
  , handRightConfidence(0.0)
  , handRightState(0)
  , handLeftConfidence(0.0)
  , handLeftState(0)
  , appearance(_alloc)
  , activities(_alloc)
  , expressions(_alloc)
  , jointOrientations(_alloc)
  , jointPositions(_alloc)
  {
  }

  typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
   ::std_msgs::Header_<ContainerAllocator>  header;

  typedef int32_t _leanTrackingState_type;
  int32_t leanTrackingState;

  typedef  ::k2_client::Lean_<ContainerAllocator>  _lean_type;
   ::k2_client::Lean_<ContainerAllocator>  lean;

  typedef uint8_t _isRestricted_type;
  uint8_t isRestricted;

  typedef uint8_t _isTracked_type;
  uint8_t isTracked;

  typedef uint64_t _trackingId_type;
  uint64_t trackingId;

  typedef int32_t _clippedEdges_type;
  int32_t clippedEdges;

  typedef uint8_t _engaged_type;
  uint8_t engaged;

  typedef float _handRightConfidence_type;
  float handRightConfidence;

  typedef int32_t _handRightState_type;
  int32_t handRightState;

  typedef float _handLeftConfidence_type;
  float handLeftConfidence;

  typedef int32_t _handLeftState_type;
  int32_t handLeftState;

  typedef  ::k2_client::Appearance_<ContainerAllocator>  _appearance_type;
   ::k2_client::Appearance_<ContainerAllocator>  appearance;

  typedef  ::k2_client::Activities_<ContainerAllocator>  _activities_type;
   ::k2_client::Activities_<ContainerAllocator>  activities;

  typedef  ::k2_client::Expressions_<ContainerAllocator>  _expressions_type;
   ::k2_client::Expressions_<ContainerAllocator>  expressions;

  typedef std::vector< ::k2_client::JointOrientationAndType_<ContainerAllocator> , typename ContainerAllocator::template rebind< ::k2_client::JointOrientationAndType_<ContainerAllocator> >::other >  _jointOrientations_type;
  std::vector< ::k2_client::JointOrientationAndType_<ContainerAllocator> , typename ContainerAllocator::template rebind< ::k2_client::JointOrientationAndType_<ContainerAllocator> >::other >  jointOrientations;

  typedef std::vector< ::k2_client::JointPositionAndState_<ContainerAllocator> , typename ContainerAllocator::template rebind< ::k2_client::JointPositionAndState_<ContainerAllocator> >::other >  _jointPositions_type;
  std::vector< ::k2_client::JointPositionAndState_<ContainerAllocator> , typename ContainerAllocator::template rebind< ::k2_client::JointPositionAndState_<ContainerAllocator> >::other >  jointPositions;


  typedef boost::shared_ptr< ::k2_client::Body_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::k2_client::Body_<ContainerAllocator>  const> ConstPtr;
  boost::shared_ptr<std::map<std::string, std::string> > __connection_header;
}; // struct Body
typedef  ::k2_client::Body_<std::allocator<void> > Body;

typedef boost::shared_ptr< ::k2_client::Body> BodyPtr;
typedef boost::shared_ptr< ::k2_client::Body const> BodyConstPtr;


template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const  ::k2_client::Body_<ContainerAllocator> & v)
{
  ros::message_operations::Printer< ::k2_client::Body_<ContainerAllocator> >::stream(s, "", v);
  return s;}

} // namespace k2_client

namespace ros
{
namespace message_traits
{
template<class ContainerAllocator> struct IsMessage< ::k2_client::Body_<ContainerAllocator> > : public TrueType {};
template<class ContainerAllocator> struct IsMessage< ::k2_client::Body_<ContainerAllocator>  const> : public TrueType {};
template<class ContainerAllocator>
struct MD5Sum< ::k2_client::Body_<ContainerAllocator> > {
  static const char* value() 
  {
    return "f2413f69b470a1bf6ed2eb6a8b85abf2";
  }

  static const char* value(const  ::k2_client::Body_<ContainerAllocator> &) { return value(); } 
  static const uint64_t static_value1 = 0xf2413f69b470a1bfULL;
  static const uint64_t static_value2 = 0x6ed2eb6a8b85abf2ULL;
};

template<class ContainerAllocator>
struct DataType< ::k2_client::Body_<ContainerAllocator> > {
  static const char* value() 
  {
    return "k2_client/Body";
  }

  static const char* value(const  ::k2_client::Body_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct Definition< ::k2_client::Body_<ContainerAllocator> > {
  static const char* value() 
  {
    return "Header header\n\
int32 leanTrackingState\n\
Lean lean\n\
bool isRestricted\n\
bool isTracked\n\
uint64 trackingId\n\
int32 clippedEdges\n\
bool engaged\n\
float32 handRightConfidence\n\
int32 handRightState\n\
float32 handLeftConfidence\n\
int32 handLeftState\n\
Appearance appearance\n\
Activities activities\n\
Expressions expressions\n\
JointOrientationAndType[] jointOrientations\n\
JointPositionAndState[] jointPositions\n\
================================================================================\n\
MSG: std_msgs/Header\n\
# Standard metadata for higher-level stamped data types.\n\
# This is generally used to communicate timestamped data \n\
# in a particular coordinate frame.\n\
# \n\
# sequence ID: consecutively increasing ID \n\
uint32 seq\n\
#Two-integer timestamp that is expressed as:\n\
# * stamp.secs: seconds (stamp_secs) since epoch\n\
# * stamp.nsecs: nanoseconds since stamp_secs\n\
# time-handling sugar is provided by the client library\n\
time stamp\n\
#Frame this data is associated with\n\
# 0: no frame\n\
# 1: global frame\n\
string frame_id\n\
\n\
================================================================================\n\
MSG: k2_client/Lean\n\
float64 leanX\n\
float64 leanY\n\
================================================================================\n\
MSG: k2_client/Appearance\n\
bool wearingGlasses\n\
================================================================================\n\
MSG: k2_client/Activities\n\
bool eyeLeftClosed\n\
bool eyeRightClosed\n\
bool mouthOpen\n\
bool mouthMoved\n\
bool lookingAway\n\
================================================================================\n\
MSG: k2_client/Expressions\n\
bool neutral\n\
bool happy\n\
================================================================================\n\
MSG: k2_client/JointOrientationAndType\n\
geometry_msgs/Quaternion orientation\n\
int32 jointType\n\
================================================================================\n\
MSG: geometry_msgs/Quaternion\n\
# This represents an orientation in free space in quaternion form.\n\
\n\
float64 x\n\
float64 y\n\
float64 z\n\
float64 w\n\
\n\
================================================================================\n\
MSG: k2_client/JointPositionAndState\n\
bool trackingState\n\
geometry_msgs/Point position\n\
int32 jointType\n\
================================================================================\n\
MSG: geometry_msgs/Point\n\
# This contains the position of a point in free space\n\
float64 x\n\
float64 y\n\
float64 z\n\
\n\
";
  }

  static const char* value(const  ::k2_client::Body_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator> struct HasHeader< ::k2_client::Body_<ContainerAllocator> > : public TrueType {};
template<class ContainerAllocator> struct HasHeader< const ::k2_client::Body_<ContainerAllocator> > : public TrueType {};
} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

template<class ContainerAllocator> struct Serializer< ::k2_client::Body_<ContainerAllocator> >
{
  template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
  {
    stream.next(m.header);
    stream.next(m.leanTrackingState);
    stream.next(m.lean);
    stream.next(m.isRestricted);
    stream.next(m.isTracked);
    stream.next(m.trackingId);
    stream.next(m.clippedEdges);
    stream.next(m.engaged);
    stream.next(m.handRightConfidence);
    stream.next(m.handRightState);
    stream.next(m.handLeftConfidence);
    stream.next(m.handLeftState);
    stream.next(m.appearance);
    stream.next(m.activities);
    stream.next(m.expressions);
    stream.next(m.jointOrientations);
    stream.next(m.jointPositions);
  }

  ROS_DECLARE_ALLINONE_SERIALIZER;
}; // struct Body_
} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::k2_client::Body_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const  ::k2_client::Body_<ContainerAllocator> & v) 
  {
    s << indent << "header: ";
s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "leanTrackingState: ";
    Printer<int32_t>::stream(s, indent + "  ", v.leanTrackingState);
    s << indent << "lean: ";
s << std::endl;
    Printer< ::k2_client::Lean_<ContainerAllocator> >::stream(s, indent + "  ", v.lean);
    s << indent << "isRestricted: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.isRestricted);
    s << indent << "isTracked: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.isTracked);
    s << indent << "trackingId: ";
    Printer<uint64_t>::stream(s, indent + "  ", v.trackingId);
    s << indent << "clippedEdges: ";
    Printer<int32_t>::stream(s, indent + "  ", v.clippedEdges);
    s << indent << "engaged: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.engaged);
    s << indent << "handRightConfidence: ";
    Printer<float>::stream(s, indent + "  ", v.handRightConfidence);
    s << indent << "handRightState: ";
    Printer<int32_t>::stream(s, indent + "  ", v.handRightState);
    s << indent << "handLeftConfidence: ";
    Printer<float>::stream(s, indent + "  ", v.handLeftConfidence);
    s << indent << "handLeftState: ";
    Printer<int32_t>::stream(s, indent + "  ", v.handLeftState);
    s << indent << "appearance: ";
s << std::endl;
    Printer< ::k2_client::Appearance_<ContainerAllocator> >::stream(s, indent + "  ", v.appearance);
    s << indent << "activities: ";
s << std::endl;
    Printer< ::k2_client::Activities_<ContainerAllocator> >::stream(s, indent + "  ", v.activities);
    s << indent << "expressions: ";
s << std::endl;
    Printer< ::k2_client::Expressions_<ContainerAllocator> >::stream(s, indent + "  ", v.expressions);
    s << indent << "jointOrientations[]" << std::endl;
    for (size_t i = 0; i < v.jointOrientations.size(); ++i)
    {
      s << indent << "  jointOrientations[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::k2_client::JointOrientationAndType_<ContainerAllocator> >::stream(s, indent + "    ", v.jointOrientations[i]);
    }
    s << indent << "jointPositions[]" << std::endl;
    for (size_t i = 0; i < v.jointPositions.size(); ++i)
    {
      s << indent << "  jointPositions[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::k2_client::JointPositionAndState_<ContainerAllocator> >::stream(s, indent + "    ", v.jointPositions[i]);
    }
  }
};


} // namespace message_operations
} // namespace ros

#endif // K2_CLIENT_MESSAGE_BODY_H

