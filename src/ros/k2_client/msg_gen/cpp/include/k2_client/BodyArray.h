/* Auto-generated by genmsg_cpp for file /home/prdemo/ros/local/k2_client/msg/BodyArray.msg */
#ifndef K2_CLIENT_MESSAGE_BODYARRAY_H
#define K2_CLIENT_MESSAGE_BODYARRAY_H
#include <string>
#include <vector>
#include <map>
#include <ostream>
#include "ros/serialization.h"
#include "ros/builtin_message_traits.h"
#include "ros/message_operations.h"
#include "ros/time.h"

#include "ros/macros.h"

#include "ros/assert.h"

#include "k2_client/Body.h"

namespace k2_client
{
template <class ContainerAllocator>
struct BodyArray_ {
  typedef BodyArray_<ContainerAllocator> Type;

  BodyArray_()
  : bodies()
  {
  }

  BodyArray_(const ContainerAllocator& _alloc)
  : bodies(_alloc)
  {
  }

  typedef std::vector< ::k2_client::Body_<ContainerAllocator> , typename ContainerAllocator::template rebind< ::k2_client::Body_<ContainerAllocator> >::other >  _bodies_type;
  std::vector< ::k2_client::Body_<ContainerAllocator> , typename ContainerAllocator::template rebind< ::k2_client::Body_<ContainerAllocator> >::other >  bodies;


  typedef boost::shared_ptr< ::k2_client::BodyArray_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::k2_client::BodyArray_<ContainerAllocator>  const> ConstPtr;
  boost::shared_ptr<std::map<std::string, std::string> > __connection_header;
}; // struct BodyArray
typedef  ::k2_client::BodyArray_<std::allocator<void> > BodyArray;

typedef boost::shared_ptr< ::k2_client::BodyArray> BodyArrayPtr;
typedef boost::shared_ptr< ::k2_client::BodyArray const> BodyArrayConstPtr;


template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const  ::k2_client::BodyArray_<ContainerAllocator> & v)
{
  ros::message_operations::Printer< ::k2_client::BodyArray_<ContainerAllocator> >::stream(s, "", v);
  return s;}

} // namespace k2_client

namespace ros
{
namespace message_traits
{
template<class ContainerAllocator> struct IsMessage< ::k2_client::BodyArray_<ContainerAllocator> > : public TrueType {};
template<class ContainerAllocator> struct IsMessage< ::k2_client::BodyArray_<ContainerAllocator>  const> : public TrueType {};
template<class ContainerAllocator>
struct MD5Sum< ::k2_client::BodyArray_<ContainerAllocator> > {
  static const char* value() 
  {
    return "eb5202664bdf63a70294b15966c92b44";
  }

  static const char* value(const  ::k2_client::BodyArray_<ContainerAllocator> &) { return value(); } 
  static const uint64_t static_value1 = 0xeb5202664bdf63a7ULL;
  static const uint64_t static_value2 = 0x0294b15966c92b44ULL;
};

template<class ContainerAllocator>
struct DataType< ::k2_client::BodyArray_<ContainerAllocator> > {
  static const char* value() 
  {
    return "k2_client/BodyArray";
  }

  static const char* value(const  ::k2_client::BodyArray_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct Definition< ::k2_client::BodyArray_<ContainerAllocator> > {
  static const char* value() 
  {
    return "Body[] bodies\n\
================================================================================\n\
MSG: k2_client/Body\n\
Header header\n\
int32 leanTrackingState\n\
Lean lean\n\
bool isRestricted\n\
bool isTracked\n\
uint64 trackingId\n\
int32 clippedEdges\n\
bool engaged\n\
float32 handRightConfidence\n\
int32 handRightState\n\
float32 handLeftConfidence\n\
int32 handLeftState\n\
Appearance appearance\n\
Activities activities\n\
Expressions expressions\n\
JointOrientationAndType[] jointOrientations\n\
JointPositionAndState[] jointPositions\n\
================================================================================\n\
MSG: std_msgs/Header\n\
# Standard metadata for higher-level stamped data types.\n\
# This is generally used to communicate timestamped data \n\
# in a particular coordinate frame.\n\
# \n\
# sequence ID: consecutively increasing ID \n\
uint32 seq\n\
#Two-integer timestamp that is expressed as:\n\
# * stamp.secs: seconds (stamp_secs) since epoch\n\
# * stamp.nsecs: nanoseconds since stamp_secs\n\
# time-handling sugar is provided by the client library\n\
time stamp\n\
#Frame this data is associated with\n\
# 0: no frame\n\
# 1: global frame\n\
string frame_id\n\
\n\
================================================================================\n\
MSG: k2_client/Lean\n\
float64 leanX\n\
float64 leanY\n\
================================================================================\n\
MSG: k2_client/Appearance\n\
bool wearingGlasses\n\
================================================================================\n\
MSG: k2_client/Activities\n\
bool eyeLeftClosed\n\
bool eyeRightClosed\n\
bool mouthOpen\n\
bool mouthMoved\n\
bool lookingAway\n\
================================================================================\n\
MSG: k2_client/Expressions\n\
bool neutral\n\
bool happy\n\
================================================================================\n\
MSG: k2_client/JointOrientationAndType\n\
geometry_msgs/Quaternion orientation\n\
int32 jointType\n\
================================================================================\n\
MSG: geometry_msgs/Quaternion\n\
# This represents an orientation in free space in quaternion form.\n\
\n\
float64 x\n\
float64 y\n\
float64 z\n\
float64 w\n\
\n\
================================================================================\n\
MSG: k2_client/JointPositionAndState\n\
bool trackingState\n\
geometry_msgs/Point position\n\
int32 jointType\n\
================================================================================\n\
MSG: geometry_msgs/Point\n\
# This contains the position of a point in free space\n\
float64 x\n\
float64 y\n\
float64 z\n\
\n\
";
  }

  static const char* value(const  ::k2_client::BodyArray_<ContainerAllocator> &) { return value(); } 
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

template<class ContainerAllocator> struct Serializer< ::k2_client::BodyArray_<ContainerAllocator> >
{
  template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
  {
    stream.next(m.bodies);
  }

  ROS_DECLARE_ALLINONE_SERIALIZER;
}; // struct BodyArray_
} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::k2_client::BodyArray_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const  ::k2_client::BodyArray_<ContainerAllocator> & v) 
  {
    s << indent << "bodies[]" << std::endl;
    for (size_t i = 0; i < v.bodies.size(); ++i)
    {
      s << indent << "  bodies[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::k2_client::Body_<ContainerAllocator> >::stream(s, indent + "    ", v.bodies[i]);
    }
  }
};


} // namespace message_operations
} // namespace ros

#endif // K2_CLIENT_MESSAGE_BODYARRAY_H

